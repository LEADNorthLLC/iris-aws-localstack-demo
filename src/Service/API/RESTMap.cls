Class DS.API.RESTMap Extends %CSP.REST
{

Parameter CHARSET = "utf-8";

Parameter CONVERTINPUTSTREAM = 1;

Parameter CONTENTTYPE = "application/json";

Parameter Version = "1.0.0";

Parameter HandleCorsRequest = 1;

XData UrlMap [ XMLNamespace = "http://www.intersystems.com/urlmap" ]
{
<Routes>
<!-- Server Info -->
<Route Url="/" Method="GET" Call="GetInfo" Cors="true"/>
<!-- Swagger specs -->
<Route Url="/_spec" Method="GET" Call="SwaggerSpec" />

<!-- Log in -->
<Route Url="/login" Method="GET" Call="UserLogin" />

<!-- List all test -->
<Route Url="/test" Method="GET" Call="GetAllTest" />
<!-- Get a test -->
<Route Url="/test/:id" Method="GET" Call="GetTest" />
<!-- Create new test -->
<Route Url="/test" Method="POST" Call="CreateTest" />
<!-- Update a test -->
<Route Url="/test/:id" Method="PUT" Call="UpdateTest" />
<!-- Delete a test -->
<Route Url="/test/:id" Method="DELETE" Call="DeleteTest" />

<!-- Get Rules --> 
<Route Url="/rules" Method="GET" Call="GetRules" Cors="true"/>

<!-- POST Profile --> 
<Route Url="/profile" Method="POST" Call="CreateProfile" />

<!-- POST CCD for Evaluation -->
<Route Url="/evaluate" Method="POST" Call="BuildRecEvalReq" />

<!-- UPDATED POST CCD for Evaluation -->
<Route Url="/validate" Method="POST" Call="Validate" />

</Routes>
}

/// Handle Cross-origin resource sharing
ClassMethod OnHandleCorsRequest(pURL As %String) As %Status
{
	
	#dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    
    #dim %request As %CSP.Request
    #dim %response As %CSP.Response
    
    #dim tOrigin,tHeaders,tMethod As %String
    
    Try {
        
        #; Get the origin
        Set tOrigin=$Get(%request.CgiEnvs("HTTP_ORIGIN"))
        set tRestrictCORS=$GET(^DSAT.RESTRICTCORS,0) 
		set tAllowedOrigin=$GET(^DSAT.ALLOWEDORIGIN,"http://localhost:3000") 
		Set ^zCors="CORS called:HandleRequest"
		Do %response.SetHeader("Access-Control-Allow-Origin","*")
		if ((tAllowedOrigin=tOrigin) || (tRestrictCORS=0))
		{       
			Set ^zCors="CORS called:Inside IF"
	        #; Allow requested origin
	        //Do ..SetResponseHeaderIfEmpty("Access-Control-Allow-Origin",tOrigin)
	        Do ..SetResponseHeaderIfEmpty("Access-Control-Allow-Origin","*")
			Do %response.SetHeader("Access-Control-Allow-Origin","*")
	        #; Set allow credentials to be true
	        Do ..SetResponseHeaderIfEmpty("Access-Control-Allow-Credentials","true")
	        
	        #; Allow requested headers
	        Set tHeaders=$Get(%request.CgiEnvs("HTTP_ACCESS_CONTROL_REQUEST_HEADERS"))
	        Do ..SetResponseHeaderIfEmpty("Access-Control-Allow-Headers",tHeaders)
	        
	        #; Allow requested method
	        Set tMethod=$Get(%request.CgiEnvs("HTTP_ACCESS_CONTROL_REQUEST_METHOD"))
	        Do ..SetResponseHeaderIfEmpty("Access-Control-Allow-Methods",tMethod)
		}
        
    } Catch (e) {
        Set tSC=e.AsStatus()
    }
    Quit tSC
}

//CNR: Copied RuleProfilesList method from CCDA Validator

/// <BR> Return a list of Rule Profiles that are active or all rule profiles
ClassMethod GetRules() As %Status
{
	Set tSC = $$$OK
	#; Quit tSC
	Try {		
		#;Dispatch request to production
		#Dim tResponse as DataService.DS.App.DynamicObject

		///$$$ThrowOnError(##class(DataService.DS.Prod.Service.ConfigService).RuleListManual(pActive,.tResponse))
		Set ^zLog="About to call method:"
	 	#; Call to Rebecca's method
    	$$$ThrowOnError(##class(DataService.DS.App.DSUtils).getRuleDefsJSONCollection("test",.tResponse))
		Set ^zLog="Method called:GetRules"


		If $$$ISERR(tResponse.Status) {
			Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		}

		#;Write output 
		If $Get(%request.CgiEnvs("HTTP_ACCEPT"),"*/*") [ "application/xml" {
			Set %response.ContentType="application/xml"
			$$$ThrowOnError(tResponse.XMLExportToStream(.tStream))
		} 
		Else {
			Set %response.ContentType="application/json"
			Set tStream=##class(%Stream.GlobalCharacter).%New()		
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).toJSON(tResponse, .tStream))
		}
		Set %response.Status = ..#HTTP200STATUSOK
		Do tStream.OutputToDevice()
		Set ^zLog="Method called:OutputToDevice"
		Do %response.SetHeader("Access-Control-Allow-Origin","*")


	} 
	Catch Ex {
		Set tSC = Ex.AsStatus()
		//If $$$TESTMODE zw tSC
		Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		Set tSC = $$$OK
	}
	Quit tSC
}



//CNR: Validate API 
//Accept file data and JSON
/// Perform real time request to evaluate a record
/// Sample request: 
/* {
    “BatchId”: <generated by UI>, (used to create batch id)
    “Doctype”: “CDA”,
    “ProfileName”: <user defined - CVS_IdRuleCheck>,
    "RulesList": [
        {
            "Name": "Allergies- Allergy: Is Populated",
        }
]
}
*/

ClassMethod Validate() As %Status
{
	Set tSC = $$$OK
	Try {
		
		If (%request.ContentType '= "multipart/form-data") {	
			//If $$$TESTMODE W "Request header type not supported, change to 'multipart/form-data'"
			Set %response.Status = ..#HTTP406NOTACCEPTABLE
			QUIT
		}
		
		// The Data should contain 2 parts, the first is JSON metadata, the second is the file data.
		// If we have MIME Data, then this is coming from Ensemble.  If we have Data then it is coming over from Angular / JQuery.
		
		#dim tFileStream As HS.SDA3.QuickStream
		if ($D(%request.Data)) 
		{
			Set name=""
			set name = %request.Next(name)
			set ^zName1 = name
			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify Data Sections."))
			Set stream = %request.Get(name)
			set ^zStreamContent1 = stream
			//do stream.Rewind()
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).fromJSON(stream,.tReqBody))	
			Set name = %request.Next(name) 

			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify Data Sections."))
			Set stream = %request.Get(name)

			//CNR: even though it's not an SDA, the CCD data is being saved to the HS.SDA3.QuickStream?
			if ('$ISOBJECT(stream))
			{
				set tFileStream = ##class(HS.SDA3.QuickStream).%New()
				$$$ThrowOnError(tFileStream.Write(stream))
				do tFileStream.Rewind()
			}
			else
			{
				set tFileStream = ##class(HS.SDA3.QuickStream).%New()
				do tFileStream.CopyFrom(stream)
				do tFileStream.Rewind()
			}
			
		}
		elseif ($D(%request.MimeData))
		{
			set tReq = ##class(%CSP.Request).%New()
			
			Set name=""
			set name = %request.NextMimeData(name)
			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify MIME Sections."))
			
			Set stream = %request.GetMimeData(name)
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).fromJSON(stream,.tReqBody))	
			Set name = %request.NextMimeData(name) 

			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify MIME Sections."))
			Set stream = %request.GetMimeData(name)
			set tFileStream = ##class(HS.SDA3.QuickStream).%New()
			$$$ThrowOnError(tFileStream.CopyFromAndSave(stream))
		}
		else
		{
			If $$$TESTMODE W "Request header type not supported, change to 'multipart/form-data'"
			Set %response.Status = ..#HTTP406NOTACCEPTABLE
			QUIT
		}
		
		#; Pull elements from API call
		Set tBatchId = tReqBody.BatchId
		Set tDoctype = tReqBody.Doctype
		Set tProfileName = tReqBody.ProfileName
		Set tRulesList = tReqBody.Rules
		
		#;Create the standard eval request
		#;Build the request - hardcoding a lot of fields
		Set tBatchGrouper = "DS"
		Set tBatchId = tBatchId
		Set tRuleProfileName = tProfileName
		Set tRecordRepresentationClass = "DataService.DS.App.Record.DocumentText:CDA"
		set tRecordSource = "QuickStream"
		set tRecordSourceKey = "T1"		
		Set tResponseContext  = "FIELD DATA, DESCRIPTOR, RULEFAILURECATEGORIES"
		Set tSourceProvider = "DS"
		Set tResultInterpretation = ""
		set tRecordName = "DS" 
		Set tSecondaryRefList = ##class(%ListOfDataTypes).%New()
		Set tRecordContextArr = ##class(%ArrayOfDataTypes).%New()

		#;Add the profile with the rule dynamically: 
		//tReq body contains the request object with list of rules as element "Rules"
		$$$ThrowOnError(##class(DataService.DS.App.DSUtils).AddUpdateRuleProfile(tProfileName,tReqBody))
		
	
		#;Submit the request
		$$$ThrowOnError(##class(DataService.DS.Prod.Service.RealTimeEvaluationService).EvaluateRequestManual(tBatchGrouper,tBatchId,tSourceProvider,tRuleProfileName,tRecordRepresentationClass,tRecordSource,tRecordSourceKey,tResponseContext,tRecordContextArr,tSecondaryRefList,tRecordName,tResultInterpretation,.tResponse))
		
		
		Set %response.Status = ..#HTTP200STATUSOK
		

		//If $$$ISERR(tResponse.Status) {
		//	Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		//}
		//Set tResponse.Status = ""
		
		#;Write output		
		If $Get(%request.CgiEnvs("HTTP_ACCEPT"),"*/*") [ "application/xml" {
			Set %response.ContentType="application/xml"
			//$$$ThrowOnError(tResponse.XMLExportToStream(.tStream))
		} 
		Else {
			Set %response.ContentType="application/json"
			Set tStream=##class(%Stream.GlobalCharacter).%New()	
			do tStream.Write("Document submitted for validation. See DynamoDB for Results.")
			//$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).toJSON(tResponse,.tStream))
		}
		Do tStream.OutputToDevice()
		
		#; Clean up the QuickStream.
		Do tFileStream.Clear(1)
		
	} 
	Catch Ex {
		Set tSC = Ex.AsStatus()
		set ^zException = Ex.Data
		//If $$$TESTMODE zw tSC
		Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		Set tSC = $$$OK
		if $ISOBJECT(tFileStream) d tFileStream.%Delete() 
		
	}
	Quit tSC
}


//CNR: Straight up copied from CCDA VAlidtor
//Accept file data and JSON
/// Perform real time request to evaluate a record
ClassMethod BuildRecEvalReq() As %Status
{
	Set tSC = $$$OK
	Try {
		
		If (%request.ContentType '= "multipart/form-data") {	
			//If $$$TESTMODE W "Request header type not supported, change to 'multipart/form-data'"
			Set %response.Status = ..#HTTP406NOTACCEPTABLE
			QUIT
		}
		
		// The Data should contain 2 parts, the first is JSON metadata, the second is the file data.
		// If we have MIME Data, then this is coming from Ensemble.  If we have Data then it is coming over from Angular / JQuery.
		
		#dim tFileStream As HS.SDA3.QuickStream
		if ($D(%request.Data)) 
		{
			Set name=""
			set name = %request.Next(name)
			set ^zName1 = name
			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify Data Sections."))
			Set stream = %request.Get(name)
			set ^zStreamContent1 = stream
			//do stream.Rewind()
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).fromJSON(stream,.tReqBody))	
			Set name = %request.Next(name) 

			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify Data Sections."))
			Set stream = %request.Get(name)
			set ^zName2 = name
			Set ^zStreamContent2 = stream
			//CNR: even though it's not an SDA, the CCD data is being saved to the HS.SDA3.QuickStream?
			if ('$ISOBJECT(stream))
			{
				set tFileStream = ##class(HS.SDA3.QuickStream).%New()
				$$$ThrowOnError(tFileStream.Write(stream))
				do tFileStream.Rewind()
			}
			else
			{
				set tFileStream = ##class(HS.SDA3.QuickStream).%New()
				do tFileStream.CopyFrom(stream)
				do tFileStream.Rewind()
			}
			
		}
		elseif ($D(%request.MimeData))
		{
			set tReq = ##class(%CSP.Request).%New()
			
			Set name=""
			set name = %request.NextMimeData(name)
			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify MIME Sections."))
			
			Set stream = %request.GetMimeData(name)
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).fromJSON(stream,.tReqBody))	
			Set name = %request.NextMimeData(name) 

			if (name = "") $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to identify MIME Sections."))
			Set stream = %request.GetMimeData(name)
			set tFileStream = ##class(HS.SDA3.QuickStream).%New()
			$$$ThrowOnError(tFileStream.CopyFromAndSave(stream))
		}
		else
		{
			If $$$TESTMODE W "Request header type not supported, change to 'multipart/form-data'"
			Set %response.Status = ..#HTTP406NOTACCEPTABLE
			QUIT
		}
		
		#;Build the request
		Set tBatchGrouper = tReqBody.BatchGrouper
		Set tBatchId = tReqBody.BatchId
		Set tRuleProfileName = tReqBody.RuleProfileName
		Set tRecordRepresentationClass = tReqBody.RecordRepresentationClass
		set tRecordSource = "QuickStream"
		set tRecordSourceKey = tFileStream.Id		
		Set tResponseContext  = tReqBody.ResponseContext
		Set tSourceProvider = tReqBody.SourceProvider
		Set tResultInterpretation = tReqBody.ResultInterpretation
		set tRecordName = tReqBody.RecordName // TODO: Do something with the Record Name!
		

		Set tSecondaryRefList = ##class(%ListOfDataTypes).%New()
		If $ISOBJECT(tReqBody.SecondaryRef) {
			For i=1:1:##class(DataService.DS.App.DynamicArray).Count(tReqBody.SecondaryRef) {
				Set tSecondaryRef = ##class(DataService.DS.Data.Serial.RecordRef).%New()
				Set tSecondaryRef.RecordSource = ##class(DataService.DS.App.DynamicArray).GetAt(tReqBody.SecondaryRef, i).RecordSource
				Set tSecondaryRef.RecordSourceKey = ##class(DataService.DS.App.DynamicArray).GetAt(tReqBody.SecondaryRef, i).RecordSourceKey
				Set tSecondaryRef.RecordRepresentationClass = ##class(DataService.DS.App.DynamicArray).GetAt(tReqBody.SecondaryRef, i).RecordRepresentationClass
				$$$ThrowOnError(tSecondaryRefList.Insert(tSecondaryRef)	)				
			}
		}
		Set tRecordContextArr = ##class(%ArrayOfDataTypes).%New()
		If $ISOBJECT(tReqBody.RecordContext) {
			Set tRecordContext = tReqBody.RecordContext
			Set tIterator = ##class(DataService.DS.App.DynamicArray).GetIterator(tRecordContext)
			Set tKey = ""
			Set tValue = ""
			While ##class(DataService.DS.App.DynamicArray).GetNext(.tRecordContext, .tIterator, .tKey, .tValue) {
				$$$ThrowOnError(tRecordContextArr.SetAt(tValue,tKey))
			}
		}

		#;Submit the request
		$$$ThrowOnError(##class(DataService.DS.Prod.Service.RealTimeEvaluationService).EvaluateRequestManual(tBatchGrouper,tBatchId,tSourceProvider,tRuleProfileName,tRecordRepresentationClass,tRecordSource,tRecordSourceKey,tResponseContext,tRecordContextArr,tSecondaryRefList,tRecordName,tResultInterpretation,.tResponse))
		
		If $$$ISERR(tResponse.Status) {
			Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		}
		Set tResponse.Status = ""
		
		#;Write output		
		If $Get(%request.CgiEnvs("HTTP_ACCEPT"),"*/*") [ "application/xml" {
			Set %response.ContentType="application/xml"
			$$$ThrowOnError(tResponse.XMLExportToStream(.tStream))
		} 
		Else {
			Set %response.ContentType="application/json"
			Set tStream=##class(%Stream.GlobalCharacter).%New()	
			$$$ThrowOnError(##class(DataService.DS.App.DynamicObject).toJSON(tResponse,.tStream))
		}
		Do tStream.OutputToDevice()
		
		#; Clean up the QuickStream.
		Do tFileStream.Clear(1)
		
	} 
	Catch Ex {
		Set tSC = Ex.AsStatus()
		set ^zException = Ex.Data
		//If $$$TESTMODE zw tSC
		Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		Set tSC = $$$OK
		if $ISOBJECT(tFileStream) d tFileStream.%Delete() 
		
	}
	Quit tSC
}


/// List test
ClassMethod GetAllTest() As %Status
{
  Return ##class(DS.API.service.TestService).GetAll()
}

/// Get a test
ClassMethod GetTest(id As %String) As %Status
{
  Return ##class(DS.API.service.TestService).GetOne(id)
}

// Create a new test

ClassMethod CreateTest() As %Status
{
  Return ##class(DS.API.service.TestService).Create()
}

// Update a test

ClassMethod UpdateTest(id As %String) As %Status
{
  Return ##class(DS.API.service.TestService).Update(id)
}

// Delete a test

ClassMethod DeleteTest(id As %String) As %Status
{
  Return ##class(DS.API.service.TestService).Delete(id)
}

/// List test categories
/// General information
ClassMethod GetInfo() As %Status
{
  SET version = ..#Version
  SET fmt=##class(%SYS.NLS.Format).%New("ptbw")
  
  SET info = {
    "Service": "Test API",
    "version": (version),
    "Developer": "Yuri Gomes",
    "Status": "Ok",
    "Date": ($ZDATETIME($HOROLOG))
  }
  Set %response.ContentType = ..#CONTENTTYPEJSON
  Set %response.Headers("Access-Control-Allow-Origin")="*"

  Write info.%ToJSON()
  Quit $$$OK
}

ClassMethod %ProcessResult(pStatus As %Status = {$$$OK}, pResult As %DynamicObject = "") As %Status [ Internal ]
{
  #dim %response As %CSP.Response
  SET tSC = $$$OK
  IF $$$ISERR(pStatus) {
    SET %response.Status = 500
    SET tSC = ..StatusToJSON(pStatus, .tJSON)
    IF $isobject(tJSON) {
      SET pResult = tJSON
    } ELSE {
      SET pResult = { "errors": [ { "error": "Unknown error parsing status code" } ] }
    }
  } 
  ELSEIF pStatus=1 {
    IF '$isobject(pResult){
      SET pResult = {
      }
    }
  }
  ELSE {
    SET %response.Status = pStatus
    SET error = $PIECE(pStatus, " ", 2, *)
    SET pResult = {
      "error": (error)
    }
  }
  
  IF pResult.%Extends("%Library.DynamicAbstractObject") {
    WRITE pResult.%ToJSON()
  }
  ELSEIF pResult.%Extends("%JSON.Adaptor") {
    DO pResult.%JSONExport()
  }
  ELSEIF pResult.%Extends("%Stream.Object") {
    DO pResult.OutputToDevice()
  }
  
  QUIT tSC
}

ClassMethod SwaggerSpec() As %Status
{
  Set tSC = ##class(%REST.API).GetWebRESTApplication($NAMESPACE, %request.Application, .swagger)
  Do swagger.info.%Remove("x-ISC_Namespace")
  Set swagger.basePath = "/test-api" 
  Set swagger.info.title = "Test API"
  Set swagger.info.version = "1.0"
  Set swagger.host = "localhost:52773"
  Return ..%ProcessResult($$$OK, swagger)
}

}